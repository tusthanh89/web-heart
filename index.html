<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trái tim và tên</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            text-align: center;
            background-color: #000;
            font-family: 'Roboto Condensed', sans-serif;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/geometries/TextGeometry.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/loaders/FontLoader.js"></script>

<script>
    // Tạo scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(0, 12, 100).setLength(150);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Điều khiển camera
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.update();

    // Tạo particles
    const xSize = 50, ySize = 50, zSize = 50, density = 3;
    const nParticles = xSize * ySize * zSize * density;

    const positions = [];
    const speed = [];
    for (let i = 0; i < nParticles; i++) {
        positions.push(new THREE.Vector3(Math.random(), Math.random(), Math.random()).multiplyScalar(100));
        speed.push(Math.random() * 10 + 2);
    }

    const pointsGeometry = new THREE.BufferGeometry().setFromPoints(positions);
    pointsGeometry.addAttribute("speed", new THREE.BufferAttribute(new Float32Array(speed), 1));
    pointsGeometry.center();

    const points = new THREE.Points(
        pointsGeometry,
        new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, size: { value: 0.9 }, ratio: { value: window.devicePixelRatio } },
            vertexShader: `
                #define PI 3.1415926  
                uniform float time;
                uniform float size;
                uniform float ratio;
                attribute float speed;
                varying vec3 vC;
                varying float vDiscard;
                void main() {
                    vec3 pos = position;
                    pos.y = mod(pos.y + speed * time, 100.) - 50.;
                    vec3 h = pos / 2.5;
                    h.y = 4. + 1.2 * h.y - abs(h.x) * sqrt(max((20. - abs(h.x)) / 15., 0.));
                    h.z = h.z * (2. - h.y / 15.);
                    float dCell = length(h) - 15.;        
                    vec3 c = vec3(11. / 255., 255. / 255., 255. / 255.);        
                    if (dCell > -0.1) c = vec3(245. / 255., 100. / 255., 186. / 255.);
                    vC = c;
                    vDiscard = dCell > 0. || dCell < -1.0 ? 1. : 0.;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = sqrt(length(pos)/30.) * size * (300.0 / -mvPosition.z) * ratio;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vC;
                varying float vDiscard;
                void main() {
                    if (vDiscard >= 0.5) { discard; }
                    if (length(gl_PointCoord - 0.5) > 0.5) { discard; }
                    gl_FragColor = vec4(vC, 1.0);
                }
            `
        })
    );
    scene.add(points);

    // Tạo văn bản
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.100.0/examples/fonts/gentilis_bold.typeface.json', function (font) {
        const textGeometry = new THREE.TextGeometry('Ngọc Duyên', {
            font: font,
            size: 10,  // Kích thước chữ
            height: 2, // Độ dày chữ
        });
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Màu trắng
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.geometry.center(); // Căn giữa văn bản
        textMesh.position.set(0, -5, 0); // Đặt vị trí văn bản trong trái tim
        scene.add(textMesh);

        // Không xoay văn bản
        renderer.setAnimationLoop(() => {
            time += clock.getDelta();
            points.material.uniforms.time.value = time;
            renderer.render(scene, camera);
        });
    });

    const clock = new THREE.Clock();
    let time = 0;

    // Đảm bảo canvas thay đổi kích thước
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
