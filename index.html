<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trái tim và tên</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            text-align: center;
            font-family: 'Roboto Condensed', sans-serif;
            background: url('648737132aeb97b5cefa.png') no-repeat center center fixed;
            background-size: cover;
        }
        canvas {
            background: transparent; /* Đảm bảo nền canvas trong suốt */
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/geometries/TextGeometry.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.100.0/examples/js/loaders/FontLoader.js"></script>

<script>
    // Tạo scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // FOV 75 độ cho không gian hẹp
    camera.position.set(0, 12, 100).setLength(120); // Giảm chiều dài để phù hợp màn hình nhỏ

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha để canvas trong suốt
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Tối ưu hóa cho thiết bị có độ phân giải cao
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Điều khiển camera
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.update();

    // Thêm background vào Scene
    const textureLoader = new THREE.TextureLoader();
    const backgroundTexture = textureLoader.load('648737132aeb97b5cefa.png'); // Thay URL này bằng ảnh nền mong muốn
    scene.background = backgroundTexture;

    // Tạo particles
    const xSize = 30, ySize = 30, zSize = 30, density = 2; // Giảm số lượng particles cho thiết bị nhỏ
    const nParticles = xSize * ySize * zSize * density;

    const positions = [];
    const speed = [];
    for (let i = 0; i < nParticles; i++) {
        positions.push(new THREE.Vector3(Math.random(), Math.random(), Math.random()).multiplyScalar(80)); // Co lại không gian particles
        speed.push(Math.random() * 10 + 2);
    }

    const pointsGeometry = new THREE.BufferGeometry().setFromPoints(positions);
    pointsGeometry.addAttribute("speed", new THREE.BufferAttribute(new Float32Array(speed), 1));
    pointsGeometry.center();

    const points = new THREE.Points(
        pointsGeometry,
        new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, size: { value: 0.6 }, ratio: { value: window.devicePixelRatio } }, // Giảm kích thước hạt
            vertexShader: `
                #define PI 3.1415926  
                uniform float time;
                uniform float size;
                uniform float ratio;
                attribute float speed;
                varying vec3 vC;
                varying float vDiscard;
                void main() {
                    vec3 pos = position;
                    pos.y = mod(pos.y + speed * time, 100.) - 50.;
                    vec3 h = pos / 2.5;
                    h.y = 4. + 1.2 * h.y - abs(h.x) * sqrt(max((20. - abs(h.x)) / 15., 0.));
                    h.z = h.z * (2. - h.y / 15.);
                    float dCell = length(h) - 15.;        
                    vec3 c = vec3(11. / 255., 255. / 255., 255. / 255.);        
                    if (dCell > -0.1) c = vec3(245. / 255., 100. / 255., 186. / 255.);
                    vC = c;
                    vDiscard = dCell > 0. || dCell < -1.0 ? 1. : 0.;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = sqrt(length(pos)/30.) * size * (300.0 / -mvPosition.z) * ratio;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vC;
                varying float vDiscard;
                void main() {
                    if (vDiscard >= 0.5) { discard; }
                    if (length(gl_PointCoord - 0.5) > 0.5) { discard; }
                    gl_FragColor = vec4(vC, 1.0);
                }
            `
        })
    );
    scene.add(points);

    // Tạo văn bản
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.100.0/examples/fonts/gentilis_bold.typeface.json', function (font) {
        const textGeometry = new THREE.TextGeometry('Ngọc Duyên', {
            font: font,
            size: 6,  // Giảm kích thước chữ
            height: 1, // Giảm độ dày chữ
        });
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.geometry.center(); // Căn giữa văn bản
        textMesh.position.set(0, -3, 0); // Đặt vị trí văn bản cân đối hơn
        scene.add(textMesh);
    });

    const clock = new THREE.Clock();
    let time = 0;

    function animate() {
        time += clock.getDelta();
        points.material.uniforms.time.value = time;
        renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);

    // Đảm bảo canvas thay đổi kích thước
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
